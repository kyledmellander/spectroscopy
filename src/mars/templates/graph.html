<style>
	.chart-container {
		display:inline-block;
		position:relative;
		width:100%;
		height:100%;
		left:10px;
		padding-bottom:145%;
		border:1px dotted silver;
		overflow:visible;
	}
	.svg-content-responsive {
		display:inline-block;
		position:absolute;
		top:10px;
		left:50px;
		bottom:10px;
		right:10px;
	}
  .axis path,
  .axis line {
    fill:none;
    stroke: #000;
    shape-rendering:crispEdges;
  }
</style>
{% extends "layouts/base.html" %}
{% block content %}
<body>
{% if graphResults %}
<!-- load the d3.js library -->
	<div class="container">
  	<div class="chart-container" id="graphJtron"></div>
      	<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
        
        
        <script>
        	function InitChart() {
            //Change JSON string to object
            var GRAPH = JSON.parse('{{graphJSON|safe}}');

            var color = d3.scale.category10();

            var jumbowidth = document.getElementById("graphJtron").offsetWidth;

            WIDTH =	Math.floor(jumbowidth*.8); 
            HEIGHT = Math.floor(WIDTH*.6);
            MARGINS = {
            				top: 50,
                    right: 0,
                    bottom: 50,
                    left: 80
                },

								lSpace = WIDTH/GRAPH.length;
            
            //Scale the graph Y Axix based on the min and max of your graphs
            var minX = Number.MAX_VALUE;
            var minY = Number.MAX_VALUE;
            var maxX = Number.MIN_VALUE;
            var maxY = Number.MIN_VALUE;

            //Update the min and maxX
            GRAPH.forEach(function (d,i) {
              //Creates an array of objects with key-value pairs, sorted by keys
              var reflectance = d3.entries(d.reflectance);
              var curX = 0;
              var cury = 0;

              for (var i=reflectance.length-1; i>=0; i--) {
                curX = parseFloat(reflectance[i].key);
                curY = parseFloat(reflectance[i].value);

                if (curX > maxX) maxX = curX;
                if (curX < minX) minX = curX;
                if (curY > maxY) maxY = curY;
                if (curY < minY) minY = curY;
              }
            });

            minX = minX *.95;
            minY = minY *.95;
            maxX = maxX * 1.05;
            maxY = maxY * 1.05;

            xScale = d3.scale.linear().range([MARGINS.left, WIDTH - MARGINS.right]).domain([minX,maxX]).clamp(true),
            yScale = d3.scale.linear().range([HEIGHT - MARGINS.top, MARGINS.bottom]).domain([minY,maxY]).clamp(true),
            xAxis = d3.svg.axis()
                .orient("bottom")
                .scale(xScale)
                .tickFormat(d3.format("d"));
            yAxis = d3.svg.axis()
                .scale(yScale)
                .orient("left");
            
            var vis = d3.select(".chart-container").append("svg")
							.attr("width", '100%')
							.attr("height", '100%')
              .attr("pointer-events","all")
              .call(d3.behavior.zoom().y(yScale).x(xScale).on("zoom",zoomed))
							.classed("svg-content-responsive",true);
            
            
            vis.append("svg:g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + (HEIGHT - MARGINS.bottom) + ")")
                .call(xAxis);

            vis.append("svg:g")
                .attr("class", "y axis")
                .attr("transform", "translate(" + (MARGINS.left) + ",0)")
                .call(yAxis);

          	vis.append("text")
          	   .attr("class", "x label")
          	   .style("text-anchor", "end")
          	   .attr("x", WIDTH-400)
          	   .attr("y", HEIGHT-10)
          	   .text("Wavelength (nm)");

          	vis.append("text")
          	   .attr("class", "y label")
          	   .style("text-anchor", "middle")
          	   .attr("transform", "translate(" + (10) + "," + (HEIGHT/2) +") rotate(-90)")
          	   .text("Reflectance");

            var lineGen = d3.svg.line()
                .x(function(d) {
                    return xScale(d.key);
                })
                .y(function(d) {
                    return yScale(d.value);
                })
                .interpolate("linear");

            //Define the function that sorts the data
            function keySort (sortfunc,field) {
              return function (a,b) {
                return sortfunc(parseFloat(a[field]),parseFloat(b[field]));
              }
            }

            var zoom = d3.behavior.zoom()
              .on("zoom",zoomed);

            var focus = vis.append("g")
              .attr("class", "focus")
              .style("display","null");

            focus.append("circle")
              .attr("r", 4)
              .attr("fill","none")
              .attr("stroke-width",1.25)
              .attr("stroke","gray");
            
            focus.append("text")
              .attr("dx",8)
              .attr("dy", "1em");


            var drawLines = GRAPH.forEach(function(d,i) {
                //Creates an array of objects with key-value pairs, sorted by keys
                var reflectanceKV = d3.entries(d.reflectance).sort(keySort(d3.ascending,"key"));

                //Append path to graph
                vis.append('svg:path')
                  .attr('d', lineGen(reflectanceKV))   //d3.entries(d.reflectance).sort(keySort(d3.ascending,"key"))
                  .attr('stroke', function(d,j) {
                          return "hsl(" + ((360/GRAPH.length+1) + (i*(360/GRAPH.length+1)))  + ",80%,30%)";
                        })
                  .attr('stroke-width', 1.25)
                  .attr('id', 'line_mcline' + i)
                  .attr('fill', 'none')
                  .on("mouseover", function() {
                    var mouseX = xScale.invert(d3.mouse(this)[0]);
                    var mouseY = yScale.invert(d3.mouse(this)[1]);
                    var coord = findClosest(reflectanceKV, mouseX);
                    focus.attr("transform", "translate(" + xScale(coord[0]) +
                                            "," + yScale(coord[1]) + ")");
                    focus.select("text")
                      .text(coord[0]+", " + coord[1]);                         
                    console.log("mouse: " + mouseX + ", " + mouseY); 
                    console.log("coord: " + coord); 
                  });
                
                // This function uses binary search to find the closest
                // X value within an array of x y coordinates
                // and returns the cooresponding coordinates
                function findClosest(graph, mouseX) {
                  var min = 0;
                      max = graph.length - 1;
                      mid = Math.floor((max+min)/2);
                      nearestX = graph[mid].key;
                      nearestY = graph[mid].value;
                      dx = Math.abs(mouseX - nearestX)
                      diff = dx;
                  
                  while (diff != 0 && (max-min) > 1) {
                    if (graph[mid].key > mouseX) {
                      max = mid; 
                    } else {
                      min = mid; 
                    }

                    mid = Math.floor((max+min)/2);
                    diff = (Math.abs(graph[mid].key - mouseX));
                    if (diff < dx) {
                      dx = diff;
                      nearestX = graph[mid].key;
                      nearestY = graph[mid].value;
                    }
                  }
                  return [nearestX, nearestY];
                }

                // Line Disappearing nonsense
                vis.append("text")
                    .attr("x", 50)
                    .attr("y", HEIGHT+20+20*i)
                    .style("fill", function(d,j) {
                            return "hsl(" + ((360/GRAPH.length+1) + (i*(360/GRAPH.length+1)))  + ",80%,30%)";
                		      })
                    .attr("class","legiend")
                    .on('click', function() {
                        var active   = d.active ? false : true;
												var color = "hsl(" + ((360/GRAPH.length+1) + (i*(360/GRAPH.length+1)))  + ",80%,30%)"
                        var opacity = active ? 0 : 1;
                        d3.select("path#line_mcline"+i).style("opacity",opacity);
                        d.active = active;
												active ? d3.select(this).style("fill","gray") : d3.select(this).style("fill",color) 
                    })
                    .text("Click to activate/deactivate: " + d.data_id + " ("+ d.name+")" );
               
            });


            function zoomed() {
              vis.select(".x.axis").call(xAxis);
              vis.select(".y.axis").call(yAxis);
              GRAPH.forEach (function(d,i) { 
                var reflectanceKV = d3.entries(d.reflectance).sort(keySort(d3.ascending,"key"));
                d3.select("path#line_mcline"+i)
                  .attr('d', lineGen(reflectanceKV));   //d3.entries(d.reflectance).sort(keySort(d3.ascending,"key"))
                });
              }

          }

          InitChart();

          </script> 
			<br>	
			<br>
      <br>
      <br>
      <br>
      <br>
  </div>
{% else%}
  <div id="meta">
    <h3><b> Please select a sample to graph.</b></h3>
  </div>
{% endif %}
</body>
{% endblock %}
